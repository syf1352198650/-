//  把前面两位数，当作参数传进来
const Fibonacci = (n, ac1 = 1, ac2 = 1) => {
  if (n <= 1) {
    return ac2;
  }

  return Fibonacci(n - 1, ac2, ac1 + ac2);
};

//函数调用会在内存形成一个“调用记录”，
// 又称为调用帧
// ，保存调用位置和内部变量等信息。递归导致的一系列嵌套函数的调用，
// 会产生一系列的调用帧，所有的调用帧就形成了一个调用栈
// 调用帧是保存在内存中的，当调用帧足够多的时候，就会出现栈溢出错误。

/* 
重复计算的问题
n = 5 ,Fibonacci(4)+Fibonacci(3)
n = 4,Fibonacci(3)+Fibonacci(2)
...
递归需要同时保存成百上千个调用帧。很容易就会发生栈溢出
但是对于尾递归来说。由于只存在一个调用栈，所以永远不会发生栈溢出错误
Fibonacci(50)
*/

console.log(Fibonacci(50));
